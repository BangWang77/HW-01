# Основные команды
Всего несколько команд нужно для базового варианта использования Git для ведения истории изменений.

## git add
Команда `git add` добавляет содержимое рабочего каталога в индекс (staging area) для последующего коммита. По умолчанию `git commit` использует лишь этот индекс, так что вы можете использовать `git add` для сборки слепка вашего следующего коммита.

Это одна из ключевых команд Git, мы упоминали о ней десятки раз на страницах книги. Ниже перечислены наиболее интересные варианты использования этой команды.

Знакомство с этой командой происходит в разделе [Отслеживание новых файлов](https://git-scm.com/book/ru/v2/ch00/r_tracking_files) главы 2.

О том как использовать `git add` для разрешения конфликтов слияния написано в разделе [Основные конфликты слияния](https://git-scm.com/book/ru/v2/ch00/r_basic_merge_conflicts) главы 3.

В разделе [Интерактивное индексирование](https://git-scm.com/book/ru/v2/ch00/r_interactive_staging) главы 7 показано как использовать `git add` для добавления в индекс лишь отдельных частей изменённого файла.

В разделе [Деревья](https://git-scm.com/book/ru/v2/ch00/r_tree_objects) показано как эта команда работает на низком уровне, чтобы вы понимали, что происходит за кулисами.

## git status
Команда `git status` показывает состояния файлов в рабочем каталоге и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.

Мы познакомили вас с этой командой в разделе [Определение состояния файлов](https://git-scm.com/book/ru/v2/ch00/r_checking_status) главы 2, разобрали стандартный и упрощённый формат вывода. И хотя мы использовали `git status` повсеместно в этой книге, практически все варианты использования покрыты в указанной главе.

## git diff
Команда `git diff` используется для вычисления разницы между любыми двумя Git деревьями. Это может быть разница между вашей рабочей копией и индексом (собственно `git diff`), разница между индексом и последним коммитом (`git diff --staged`), или между любыми двумя коммитами (`git diff master branchB`).

Мы познакомили вас с основами этой команды в разделе [Просмотр индексированных](https://git-scm.com/book/ru/v2/ch00/r_git_diff_staged) и [неиндексированных изменений](https://git-scm.com/book/ru/v2/ch00/r_git_diff_staged) главы 2, где показали как посмотреть какие изменения уже добавлены в индекс, а какие — ещё нет.

О том как использовать эту команду для проверки на проблемы с пробелами с помощью аргумента `--check` можно почитать в разделе [Правила создания коммитов](https://git-scm.com/book/ru/v2/ch00/r_commit_guidelines) главы 5.

Мы показали вам как эффективно сравнивать ветки используя синтаксис `git diff A…​B` в разделе [Определение применяемых изменений](https://git-scm.com/book/ru/v2/ch00/r_what_is_introduced) главы 5.

В разделе [Продвинутое слияние](https://git-scm.com/book/ru/v2/ch00/r_advanced_merging) главы 7 показано использование опции `-w` для скрытия различий в пробельных символах, а также рассказано как сравнивать конфликтующие изменения с опциями `--theirs`, `--ours` и `--base`.

Использование этой команды с опцией `--submodule` для сравнения изменений в подмодулях показано в разделе [Начало работы с подмодулями](https://git-scm.com/book/ru/v2/ch00/r_starting_submodules) главы 7.

## git difftool
Команда `git difftool` просто запускает внешнюю утилиту сравнения для показа различий в двух деревьях, на случай если вы хотите использовать что-либо отличное от встроенного просмотрщика `git diff`.

Мы лишь вкратце упомянули о ней в разделе [Просмотр индексированных и неиндексированных изменений](https://git-scm.com/book/ru/v2/ch00/r_git_diff_staged) главы 2.

## git commit
Команда `git commit` берёт все данные, добавленные в индекс с помощью `git add`, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.

Вы познакомились с основами модели коммитов в разделе [Коммит изменений](https://git-scm.com/book/ru/v2/ch00/r_committing_changes) главы 2. Там же мы продемонстрировали использование опций `-a` для добавления всех изменений в индекс без использования `git add`, что может быть удобным в повседневном использовании, и `-m` для передачи сообщения коммита без запуска полноценного редактора.

В разделе [Операции отмены](https://git-scm.com/book/ru/v2/ch00/r_undoing) главы 2 мы рассказали об опции `--amend`, используемой для изменения последнего совершённого коммита.

В разделе [О ветвлении в двух словах](https://git-scm.com/book/ru/v2/ch00/r_git_branches_overview) главы 3 мы более подробно познакомились с тем, что делает команда `git commit` и почему она делает это именно так.

Мы показали вам как подписывать ваши коммиты, используя опцию `-S` в разделе [Подпись коммитов](https://git-scm.com/book/ru/v2/ch00/r_signing_commits) главы 7.

И наконец мы заглянули внутрь команды `git commit` в разделе [Объекты коммитов](https://git-scm.com/book/ru/v2/ch00/r_git_commit_objects) главы 10 и узнали что она делает за кулисами.

## git reset
Команда `git reset`, как можно догадаться из названия, используется в основном для отмены изменений. Она изменяет указатель `HEAD` и, опционально, состояние индекса. Также эта команда может изменить файлы в рабочем каталоге при использовании параметра `--hard`, что может привести к потере наработок при неправильном использовании, так что убедитесь в серьёзности своих намерений прежде чем использовать его.

Мы рассказали об основах использования `git reset` в разделе ][Отмена индексации файла](https://git-scm.com/book/ru/v2/ch00/r_unstaging) главы 2, где эта команда использовалась для удаления файла из индекса, добавленного туда с помощью `git add`.

В разделе [Раскрытие тайн reset](https://git-scm.com/book/ru/v2/ch00/r_git_reset), полностью посвящённой этой команде, мы разобрались в деталях её использования.

Мы использовали `git reset --hard` чтобы отменить слияние в разделе [Прерывание слияния](https://git-scm.com/book/ru/v2/ch00/r_abort_merge) главы 7, там же было продемонстрировано использование команды `git merge --abort` для этих целей, которая работает как обёртка над `git reset`.

## git rm
Команда `git rm` используется в Git для удаления файлов из индекса и рабочей копии. Она похожа на `git add` с тем лишь исключением, что она удаляет, а не добавляет файлы для следующего коммита.

Мы немного разобрались с этой командой в разделе [Удаление файлов](https://git-scm.com/book/ru/v2/ch00/r_removing_files) главы 2, показали как удалять файлы из рабочего каталога и индекса и только из индекса, используя флаг `--cached`.

Ещё один вариант использования `git rm` приведён в разделе ][Удаление объектов](https://git-scm.com/book/ru/v2/ch00/r_removing_objects) главы 10, где мы вкратце объяснили как использовать опцию `--ignore-unmatch` при выполнении `git filter-branch`, которая подавляет ошибки удаления несуществующих файлов. Это может быть полезно для автоматически выполняемых скриптов.

## git mv
Команда `git mv` — это всего лишь удобный способ переместить файл, а затем выполнить `git add` для нового файла и `git rm` для старого.

Мы лишь вкратце упомянули эту команду в разделе [Перемещение файлов](https://git-scm.com/book/ru/v2/ch00/r_git_mv) главы 2.

## git clean
Команда `git clean` используется для удаления мусора из рабочего каталога. Это могут быть результаты сборки проекта или файлы конфликтов слияний.

[На главную](/readme.md)